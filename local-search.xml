<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>连续空闲内存合并管理</title>
    <link href="/2023/05/26/%E8%BF%9E%E7%BB%AD%E7%A9%BA%E9%97%B2%E5%86%85%E5%AD%98%E5%90%88%E5%B9%B6%E7%AE%A1%E7%90%86/"/>
    <url>/2023/05/26/%E8%BF%9E%E7%BB%AD%E7%A9%BA%E9%97%B2%E5%86%85%E5%AD%98%E5%90%88%E5%B9%B6%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="题目要求"><a class="markdownIt-Anchor" href="#题目要求"></a> 题目要求</h1><p>动态内存管理根据用户的需求分配任意大小的内存，当用户释放内存时，被释放的内存回到池(堆)中供其他用户使用。现设计某实时操作系统计划的内存管理功能，请你实现被释放内存的回收合并模块，当经过一次内存释放操作后，请返回当前最大的连续内存块的起始位置，以及此连续内存的数量(块数)。若存在多个最大连续内存块，侧返回编号最小的内存块信息<br>当前已经把连续内存，按块进行连续编号</p><h1 id="输入样例"><a class="markdownIt-Anchor" href="#输入样例"></a> 输入样例</h1><h2 id="输入"><a class="markdownIt-Anchor" href="#输入"></a> 输入</h2><ol><li>样例1<ul><li>输入：1,3,2,5<br>表示释放四块内存，ID分别为1,3,2,5，每块内存的大小为1个单位</li><li>预制条件：函数执行前，所有内存均已被申请完毕，无空闲，不需考虑内存重复释放</li><li>取值范围：内存ID编号：0&lt;ID&lt;2^31-1,单次释放的内存个数&lt;10000</li><li>输出：1,3<br>经过回收处理后，当前可用的最大连续内存大小3，以及次内存的起始编号1<br>说明：1,3,2,5四块内存前三块1,3,2为连续内存，合并后的连续内存为3个单位。起始编号为1，故返回1,3</li></ul></li><li>样例2<ul><li>输入：2,4,3,7,6<br>表示释放5块内存，ID分别为2,4,3,7,6</li><li>输出：2,3<br>经过回收处理后，2,3,4三块内存连续，可以合并为一块大内存，大小为3个单位；6,7内存连续，合并后的连续内存大小为2<br>说明：比较后，合并后的最大连续内存为3个单位。起始编号为2，故返回2,3</li></ul></li></ol><hr><h1 id="实现思路"><a class="markdownIt-Anchor" href="#实现思路"></a> 实现思路</h1><ol><li>要判断数组中元素是否连续，我一开始的判断是对数组进行切分取得最大值max与最小值min，若max-min等于子数组长度时，则该子数组为连续，但没有联想起相关api方法；于是分析测试用例：分析输入1，3，2，5，输出1，3；其中1，3，2是连续的内存，但是1，3在是否连续的判断中是不相邻的，也就是说，如果只是对原始序列进行简单的相邻递增或递减判断是不合适的，于是先对输入数组a进行排序得到数组a1，再取得a1中相邻两个数之间的差值，存放在一个新数组b中，如果是相邻的元素是连续的，即差值为1，那么数组b中连续1的个数+1则为数组a1中含有连续数字的个数</li><li>另一个问题出现，此时分析内存再比如输入数组a为3，4，1，5，排序后的数组a1是1，3，4，5，看起来排序后新数组3，4，5是相邻的，但是原输入数组中只有3，4挨在一起算连续内存，而原输入中5被1隔开了，所以输出应该是3，2，起始内存为3，内存大小为2，此时又对排序后的是否相邻的判断做出了限制</li><li>考虑到此，即连续内存既需要内存编号数字是连续的，又需要内存编号在原输入数组中是挨在一起的，即在原数组a中的index索引是连续的，要判断index索引是否连续，则只需要取得内存编号数字连续的数组对应于a中的索引数组，对索引数组统计部分连续的数字长度即可得到原数组a中连续内存的长度</li><li>鉴于原输入数组中连续内存个数可能有多个，并且需要记录连续内存的编号，将升序数组a1中含有连续数字的数目记录在一个数组count中，且数目对应的索引为连续数字在a1中的起始索引</li></ol><h1 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h1><ol><li>对排好序的序列求相邻两元素的差值，并统计相应数目</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] statistics(ArrayList&lt;Integer&gt; a1) &#123;  <br>    <span class="hljs-comment">//集合b用于存放升序排列的输入序列的相邻元素差值  </span><br>    ArrayList&lt;Integer&gt; b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();  <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; a1.size() - <span class="hljs-number">1</span>; i++) &#123;  <br>        b.add(a1.get(i + <span class="hljs-number">1</span>) - a1.get(i));  <br>    &#125;  <br>    <span class="hljs-comment">//计数君计数连续数字的个数  </span><br>    <span class="hljs-type">int</span>[] count = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[b.size()];  <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; b.size(); i++) &#123;  <br>        <span class="hljs-comment">//这里i即为a1中连续数字的起始位置索引  </span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> i;  <br>        <span class="hljs-comment">//出现1  </span><br>        <span class="hljs-keyword">if</span> (b.get(i) == <span class="hljs-number">1</span>) &#123;  <br>            count[i] = <span class="hljs-number">1</span>;  <br>            <span class="hljs-comment">//往后找是否有连1  </span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; b.size(); j++) &#123;  <br>                <span class="hljs-keyword">if</span> (b.get(j) == <span class="hljs-number">1</span>) &#123;  <br>                    count[i]++;  <br>                &#125; <span class="hljs-keyword">else</span> &#123;  <br>                    <span class="hljs-comment">//下一个不是1,break  </span><br>                    <span class="hljs-keyword">break</span>;  <br>                &#125;  <br>            &#125;  <br>            <span class="hljs-comment">//跳过连1段落  </span><br>            i = i + count[i];  <br>            <span class="hljs-comment">//补1，n个数差值有n-1个1  </span><br>            count[k]++;  <br>        &#125;  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> count;  <br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>根据起始索引i和连续长度截取得到连续数组(该方法用于截取排好序后的a1和原输入序列a)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//根据起始索引i和连续长度截取得到连续数组  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] getcontinuenumber(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> max, ArrayList&lt;Integer&gt; a) &#123;  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">toIndex</span> <span class="hljs-operator">=</span> max + index;  <br>    <span class="hljs-type">int</span>[] ints = a.subList(index, toIndex).stream().mapToInt(Integer::valueOf).toArray();  <br>    <span class="hljs-keyword">return</span> ints;  <br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>判断伪连续数组对应在输入a中的索引是不是连续的，若部分连续，则取得起始点以及连续大小</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//判断伪连续数组对应在输入a中的索引是不是连续的，若部分连续，则取得起始点以及连续大小  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ArrayList <span class="hljs-title function_">getrealcontinue</span><span class="hljs-params">(<span class="hljs-type">int</span>[] findcontine, ArrayList&lt;Integer&gt; a)</span> &#123;  <br>    ArrayList&lt;Integer&gt; index = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();  <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; findcontine.length; i++) &#123;  <br>        index.add(a.indexOf(findcontine[i]));  <br>    &#125;  <br>    Collections.sort(index);  <br>    <span class="hljs-type">int</span>[] count = statistics(index);  <br>    <span class="hljs-type">ArrayList</span> <span class="hljs-variable">returnresult</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();  <br>    <span class="hljs-type">int</span>[] maxByFor1 = findMaxByFor(count);  <br>    <span class="hljs-comment">//最大连续索引的数目  </span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> maxByFor1[<span class="hljs-number">0</span>];  <br>    <span class="hljs-comment">//起始索引  </span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">maxindex</span> <span class="hljs-operator">=</span> maxByFor1[<span class="hljs-number">1</span>];  <br>    <span class="hljs-comment">//a中的起始索引  </span><br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> index.get(maxindex);  <br>    returnresult.add(i);  <br>    returnresult.add(max);  <br>    <span class="hljs-keyword">return</span> returnresult;  <br>&#125;<br><br><span class="hljs-comment">//得到计数君count里的最大值和对应索引  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] findMaxByFor(<span class="hljs-type">int</span>[] arr) &#123;  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 最大值  </span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//对应索引  </span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;  <br>        <span class="hljs-keyword">if</span> (arr[i] &gt; max) &#123;  <br>            max = arr[i];  <br>            index = i;  <br>        &#125;  <br>    &#125;  <br>    <span class="hljs-type">int</span>[] ints = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>];  <br>    ints[<span class="hljs-number">0</span>] = max;  <br>    ints[<span class="hljs-number">1</span>] = index;  <br>    <span class="hljs-keyword">return</span> ints;  <br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>根据对a1中连续数字的统计count逐个截取得到在a1中的连续子序列，再回到a中寻找对应索引，统计在a中连续内存的个数和起始节点</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Java">ArrayList&lt;ArrayList&lt;Integer&gt;&gt; integerLists = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();  <br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; count.length; i++) &#123;  <br>    <span class="hljs-keyword">if</span> (count[i] != <span class="hljs-number">0</span>) &#123;  <br>        <span class="hljs-type">int</span>[] findcontine = getcontinuenumber(i, count[i], a1);  <br>        <span class="hljs-comment">//System.out.println(Arrays.toString(findcontine));  </span><br>        <span class="hljs-comment">//现在判断得到的伪连续数组的索引是否是连续的，统计部分连续的数目  </span><br>        <span class="hljs-type">ArrayList</span> <span class="hljs-variable">getrealcontinue</span> <span class="hljs-operator">=</span> getrealcontinue(findcontine, a);<span class="hljs-comment">//这里存放该（单个）连续数组的真实连续的起始索引，长度  </span><br>  <br>        integerLists.add(getrealcontinue);<span class="hljs-comment">//存放多个连续数组的信息  </span><br>        <span class="hljs-comment">//System.out.println(integerLists);  </span><br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><ol start="5"><li>遍历收集到的多个连续数组的信息，判断哪个的连续数量最大</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//判断连续数组哪个连续数量最大  </span><br><span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <br><span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <br><span class="hljs-keyword">for</span> (ArrayList&lt;Integer&gt; integerList : integerLists) &#123;  <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; integerList.size(); i++) &#123;  <br>        <span class="hljs-keyword">if</span> (integerList.get(<span class="hljs-number">1</span>) &gt;= max) &#123;  <br>            max = integerList.get(<span class="hljs-number">1</span>);  <br>            index = integerList.get(<span class="hljs-number">0</span>);  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><ol start="6"><li>根据最大连续内存的信息：起始索引和长度在a中截取到该连续内存数组,找到由于该连续内存数组在a中可能是乱序，故找到起其中最小数作为起始编号</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//找到最小数(起始）的索引  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findStartindex</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> arr[<span class="hljs-number">0</span>];  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">minindex</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;  <br>        <span class="hljs-keyword">if</span> (arr[i] &lt; min) &#123;  <br>            min = arr[i];  <br>            minindex = i;  <br>        &#125;  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> minindex;  <br>&#125;<br></code></pre></td></tr></table></figure><ol start="7"><li>输出结果</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">int</span>[] findfinal = getcontinuenumber(index, max, a);  <br><span class="hljs-type">int</span> <span class="hljs-variable">startindex</span> <span class="hljs-operator">=</span> findStartindex(findfinal);  <br>System.out.println(findfinal[startindex] + <span class="hljs-string">&quot;,&quot;</span> + max);<br></code></pre></td></tr></table></figure><h1 id="完整代码"><a class="markdownIt-Anchor" href="#完整代码"></a> 完整代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">package</span> HuaweiTest1_5_24;  <br>  <br><span class="hljs-keyword">import</span> java.util.*;  <br><span class="hljs-keyword">import</span> java.util.stream.Collectors;  <br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test3</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-comment">//获取输入  </span><br>        ArrayList&lt;Integer&gt; a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();  <br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);  <br>        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> sc.nextLine();  <br>        <span class="hljs-comment">//根据，切分数据  </span><br>        String[] split = s.split(<span class="hljs-string">&quot;,&quot;</span>);  <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; split.length; i++) &#123;  <br>            a.add(Integer.valueOf(split[i]));  <br>        &#125;  <br>  <br>        <span class="hljs-comment">//对输入序列进行排序，存放在a1  </span><br>        ArrayList&lt;Integer&gt; a1 = (ArrayList&lt;Integer&gt;) a.stream().sorted((o1, o2) -&gt; o1 - o2).collect(Collectors.toList());  <br>        <span class="hljs-comment">//得到升序序列a1中连续数字的个数，count的索引为对应a1中连续数字的起始索引  </span><br>        <span class="hljs-type">int</span>[] count = statistics(a1);  <br>        <span class="hljs-comment">//System.out.println(Arrays.toString(count));  </span><br>  <br>  <br>        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; integerLists = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();  <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; count.length; i++) &#123;  <br>            <span class="hljs-keyword">if</span> (count[i] != <span class="hljs-number">0</span>) &#123;  <br>                <span class="hljs-type">int</span>[] findcontine = getcontinuenumber(i, count[i], a1);  <br>                <span class="hljs-comment">//System.out.println(Arrays.toString(findcontine));  </span><br>                <span class="hljs-comment">//现在判断得到的伪连续数组的索引是否是连续的，统计部分连续的数目  </span><br>                <span class="hljs-type">ArrayList</span> <span class="hljs-variable">getrealcontinue</span> <span class="hljs-operator">=</span> getrealcontinue(findcontine, a);<span class="hljs-comment">//这里存放该（单个）连续数组的真实连续的起始索引，长度  </span><br>  <br>                integerLists.add(getrealcontinue);<span class="hljs-comment">//存放多个连续数组的信息  </span><br>                <span class="hljs-comment">//System.out.println(integerLists);  </span><br>            &#125;  <br>        &#125;  <br>        <span class="hljs-comment">//判断连续数组哪个连续数量最大  </span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <br>        <span class="hljs-keyword">for</span> (ArrayList&lt;Integer&gt; integerList : integerLists) &#123;  <br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; integerList.size(); i++) &#123;  <br>                <span class="hljs-keyword">if</span> (integerList.get(<span class="hljs-number">1</span>) &gt;= max) &#123;  <br>                    max = integerList.get(<span class="hljs-number">1</span>);  <br>                    index = integerList.get(<span class="hljs-number">0</span>);  <br>                &#125;  <br>            &#125;  <br>        &#125;  <br>        <span class="hljs-type">int</span>[] findfinal = getcontinuenumber(index, max, a);  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">startindex</span> <span class="hljs-operator">=</span> findStartindex(findfinal);  <br>        System.out.println(findfinal[startindex] + <span class="hljs-string">&quot;,&quot;</span> + max);  <br>    &#125;  <br>  <br>    <span class="hljs-comment">//判断伪连续数组对应在输入a中的索引是不是连续的，若部分连续，则取得起始点以及连续大小  </span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ArrayList <span class="hljs-title function_">getrealcontinue</span><span class="hljs-params">(<span class="hljs-type">int</span>[] findcontine, ArrayList&lt;Integer&gt; a)</span> &#123;  <br>        ArrayList&lt;Integer&gt; index = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();  <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; findcontine.length; i++) &#123;  <br>            index.add(a.indexOf(findcontine[i]));  <br>        &#125;  <br>  <br>        <span class="hljs-comment">//System.out.println(index);  </span><br>        Collections.sort(index);  <br>        <span class="hljs-type">int</span>[] count = statistics(index);  <br>        <span class="hljs-comment">//System.out.println(Arrays.toString(count));  </span><br>        <span class="hljs-type">ArrayList</span> <span class="hljs-variable">returnresult</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();  <br>        <span class="hljs-type">int</span>[] maxByFor1 = findMaxByFor(count);  <br>        <span class="hljs-comment">//最大连续索引的数目  </span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> maxByFor1[<span class="hljs-number">0</span>];  <br>        <span class="hljs-comment">//起始索引  </span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxindex</span> <span class="hljs-operator">=</span> maxByFor1[<span class="hljs-number">1</span>];  <br>        <span class="hljs-comment">//a中的起始索引  </span><br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> index.get(maxindex);  <br>        returnresult.add(i);  <br>        returnresult.add(max);  <br>        <span class="hljs-keyword">return</span> returnresult;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">//对排好序的序列求相邻两元素的差值，并统计相应数目  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] statistics(ArrayList&lt;Integer&gt; a1) &#123;  <br>        <span class="hljs-comment">//集合b用于存放升序排列的输入序列的相邻元素差值  </span><br>        ArrayList&lt;Integer&gt; b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();  <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; a1.size() - <span class="hljs-number">1</span>; i++) &#123;  <br>            b.add(a1.get(i + <span class="hljs-number">1</span>) - a1.get(i));  <br>        &#125;  <br>        <span class="hljs-comment">//计数君计数连续数字的个数  </span><br>        <span class="hljs-type">int</span>[] count = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[b.size()];  <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; b.size(); i++) &#123;  <br>            <span class="hljs-comment">//这里i即为a1中连续数字的起始位置索引  </span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> i;  <br>            <span class="hljs-comment">//出现1  </span><br>            <span class="hljs-keyword">if</span> (b.get(i) == <span class="hljs-number">1</span>) &#123;  <br>                count[i] = <span class="hljs-number">1</span>;  <br>                <span class="hljs-comment">//往后找是否有连1  </span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; b.size(); j++) &#123;  <br>                    <span class="hljs-keyword">if</span> (b.get(j) == <span class="hljs-number">1</span>) &#123;  <br>                        count[i]++;  <br>                    &#125; <span class="hljs-keyword">else</span> &#123;  <br>                        <span class="hljs-comment">//下一个不是1,break  </span><br>                        <span class="hljs-keyword">break</span>;  <br>                    &#125;  <br>                &#125;  <br>                <span class="hljs-comment">//跳过连1段落  </span><br>                i = i + count[i];  <br>                <span class="hljs-comment">//补1，n个数差值有n-1个1  </span><br>                count[k]++;  <br>            &#125;  <br>        &#125;  <br>        <span class="hljs-keyword">return</span> count;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">//得到计数君count里的最大值和对应索引  </span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] findMaxByFor(<span class="hljs-type">int</span>[] arr) &#123;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 最大值  </span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//对应索引  </span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;  <br>            <span class="hljs-keyword">if</span> (arr[i] &gt; max) &#123;  <br>                max = arr[i];  <br>                index = i;  <br>            &#125;  <br>        &#125;  <br>        <span class="hljs-type">int</span>[] ints = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>];  <br>        ints[<span class="hljs-number">0</span>] = max;  <br>        ints[<span class="hljs-number">1</span>] = index;  <br>        <span class="hljs-keyword">return</span> ints;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">//根据起始索引i和连续长度截取得到连续数组  </span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] getcontinuenumber(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> max, ArrayList&lt;Integer&gt; a) &#123;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">toIndex</span> <span class="hljs-operator">=</span> max + index;  <br>        <span class="hljs-type">int</span>[] ints = a.subList(index, toIndex).stream().mapToInt(Integer::valueOf).toArray();  <br>        <span class="hljs-keyword">return</span> ints;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">//找到最小数(起始）的索引  </span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findStartindex</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> arr[<span class="hljs-number">0</span>];  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">minindex</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;  <br>            <span class="hljs-keyword">if</span> (arr[i] &lt; min) &#123;  <br>                min = arr[i];  <br>                minindex = i;  <br>            &#125;  <br>        &#125;  <br>        <span class="hljs-keyword">return</span> minindex;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h1 id="结束"><a class="markdownIt-Anchor" href="#结束"></a> 结束</h1>]]></content>
    
    
    <categories>
      
      <category>Fundamentals</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Jupyter NoteBook</title>
    <link href="/2023/04/05/Jupyter%20NoteBook/"/>
    <url>/2023/04/05/Jupyter%20NoteBook/</url>
    
    <content type="html"><![CDATA[<pre><code class="hljs"># 基础</code></pre><h2 id="基本操作和快捷键"><a class="markdownIt-Anchor" href="#基本操作和快捷键"></a> 基本操作和快捷键</h2><ol><li>ctrl+回车： 运行当前单元格</li><li>alt+回车:运行当前单元格并在下方创建一个单元格</li><li>shift+回车:运行当前单元格并选中下方一个单元格</li><li>选中单元格+M:单元格变成Markdown块</li><li>选中单元格+Y:单元格变成代码块</li></ol><h1 id="高级"><a class="markdownIt-Anchor" href="#高级"></a> 高级</h1><h2 id="魔法命令"><a class="markdownIt-Anchor" href="#魔法命令"></a> 魔法命令</h2><h3 id="run"><a class="markdownIt-Anchor" href="#run"></a> %run</h3><ol><li>在Jupter NoteBook中调用Myscript工程下的hello.py代码</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">hello</span>(<span class="hljs-params">name</span>):  <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello&quot;</span>, name, <span class="hljs-string">&quot;!&quot;</span>)  <br>    <br>hello(<span class="hljs-string">&quot;Machine Learning&quot;</span>)<br></code></pre></td></tr></table></figure><ol start="2"><li>%run命令运行该脚本，且可读取到hello()函数</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Python">%run Myscript/hello.py<br>hello(<span class="hljs-string">&#x27;嗮嗮&#x27;</span>);<br></code></pre></td></tr></table></figure><ol start="3"><li>加载整个模块<ol><li>mymodule模块，<a href="http://xn--FirstML-nw3kp17p.py">下有FirstML.py</a>（predict函数）和__init__.py</li></ol> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">predict</span>(<span class="hljs-params">x</span>):  <br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;?&quot;</span>)<br></code></pre></td></tr></table></figure><ol start="2"><li>import模块</li></ol> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> mymodule.FirstML<br>mymodule.FirstML.predict(<span class="hljs-number">1</span>);<span class="hljs-comment">#?</span><br></code></pre></td></tr></table></figure><ol start="3"><li>常用：</li></ol> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> mymodule <span class="hljs-keyword">import</span> FirstML<br><br>FirstML.predict(<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure></li></ol><h3 id="timeit"><a class="markdownIt-Anchor" href="#timeit"></a> %timeit</h3><ol><li>注意:后面只能接一句话</li><li>测试运行时间 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Python">%timeit L=[i**<span class="hljs-number">2</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1000</span>)];<br><span class="hljs-comment">#196 µs ± 931 ns per loop (mean ± std. dev. of 7 runs, 1000 loops each)</span><br>%timeit L=[i**<span class="hljs-number">2</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1000000</span>)];<br><span class="hljs-comment">#212 ms ± 1.16 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)</span><br><span class="hljs-comment">#复杂度线性 O(n)</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="timeit-2"><a class="markdownIt-Anchor" href="#timeit-2"></a> %%timeit</h3><ol><li>注意：可以接代码段</li><li>%%区域命令符</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Python"> %%timeit<br>L=[]<br><span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1000</span>):<br>    L.append(n**<span class="hljs-number">2</span>)<br><span class="hljs-comment">#这里使用for循环生成L，前一例子使用List的生成表达式更快</span><br></code></pre></td></tr></table></figure><h3 id="time"><a class="markdownIt-Anchor" href="#time"></a> %time</h3><ol><li>注意：不希望想前两个一样系统执行多次，只希望执行一次，但此时不稳定</li><li>区域化还是%%time</li><li>此时多次生成或者排后测量是不一样的时间，无法真实反映</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> random<br>L=[random.random() <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100000</span>)]<br>%timeit L.sort()<br>%timeit L.sort()<br></code></pre></td></tr></table></figure><ol start="4"><li>说明：random()函数</li></ol><h3 id="其他魔法命令"><a class="markdownIt-Anchor" href="#其他魔法命令"></a> 其他魔法命令</h3><ul><li>%lsmagic:输出所有魔法命令</li><li>%run? 查看run命令的文档</li></ul>]]></content>
    
    
    <categories>
      
      <category>Note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ML</tag>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Markdown语法</title>
    <link href="/2023/03/31/Markdown%E8%AF%AD%E6%B3%95/"/>
    <url>/2023/03/31/Markdown%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="常用语法"><a class="markdownIt-Anchor" href="#常用语法"></a> 常用语法</h1><ol><li>标题：#+空格，共有六级标题（6个#）</li><li><strong>加粗</strong>：在需加粗的内容两边加两个星号</li></ol><ul><li>快捷键：选中，<strong>Ctrl+B</strong></li></ul><ol start="3"><li><em>斜体</em>：左右各一个星号</li><li><s>删除线</s> ： 左右各两条波浪线</li><li>列表（缩进控制）<ul><li>有序列表：数字+‘.’+空格，回车自动编号</li><li>无序列表：‘星号*’+空格，回车自动编号</li><li>可控制缩进（TAB键），取消缩进（shift+TAB键）</li></ul></li><li>引用：渲染出引用效果,&gt;+输入引用内容</li></ol><blockquote><p>我是<em><strong>引用文字</strong></em>（名人名言）</p></blockquote><ul><li>注意： 引用前后需加入空白行）</li></ul><ol start="7"><li>分隔线:三个‘-’+回车</li></ol><hr><ol start="8"><li>链接：‘中括号[]内填写链接名/描述’+‘小括号\（）内填写链接地址’<br><a href="https://chuanzaiii.github.io/">我的个人博客</a></li></ol><ul><li>快捷键：<strong>Ctrl+K</strong></li></ul><ol start="9"><li>代码/代码块: 前后三个`，可在第一行指定程序语言，中间写代码</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">package</span> com.demo.service;  <br><span class="hljs-keyword">import</span> com.demo.pojo.Gpa;  <br><span class="hljs-keyword">import</span> com.demo.pojo.PageBean;  <br><span class="hljs-keyword">import</span> com.demo.pojo.Score;  <br><span class="hljs-keyword">import</span> java.util.List;  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ScoreService</span> &#123;  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 查询所有  </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span>  </span><br><span class="hljs-comment">     */</span>    List&lt;Score&gt; <span class="hljs-title function_">selectALl</span><span class="hljs-params">()</span>;  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 添加  </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> score  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">addScore</span><span class="hljs-params">(Score score)</span>;  <br>    PageBean&lt;Score&gt; <span class="hljs-title function_">selectByPageAndCondition</span><span class="hljs-params">(<span class="hljs-type">int</span> currentPage,<span class="hljs-type">int</span> pageSize,Score score)</span>;  <br>    Gpa <span class="hljs-title function_">selectTotalGpa</span><span class="hljs-params">(Score score)</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><ol start="10"><li>任务列表：- [ ]  横杠+空格+中括号（中括号内加空格是未选中 加x是选中）+空格</li></ol><ul><li>[ ] 今日任务1</li><li>[x] 今日任务2</li></ul><ul><li>快捷键：<strong>Ctrl+L</strong>（第一次是未选中，第二次是选中）</li></ul><h1 id="注意"><a class="markdownIt-Anchor" href="#注意"></a> 注意</h1><ol><li>标题# 后面空一格</li><li>段落之间、引用前后空一行</li></ol>]]></content>
    
    
    <categories>
      
      <category>Fundamentals</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微波-半波对称振子</title>
    <link href="/2023/03/27/%E5%BE%AE%E6%B3%A2-%E5%8D%8A%E6%B3%A2%E5%AF%B9%E7%A7%B0%E6%8C%AF%E5%AD%90/"/>
    <url>/2023/03/27/%E5%BE%AE%E6%B3%A2-%E5%8D%8A%E6%B3%A2%E5%AF%B9%E7%A7%B0%E6%8C%AF%E5%AD%90/</url>
    
    <content type="html"><![CDATA[<h1 id="使用hfss软件设计建模半波对称振子结构"><a class="markdownIt-Anchor" href="#使用hfss软件设计建模半波对称振子结构"></a> 使用HFSS软件设计建模半波对称振子结构</h1><h2 id="主要仿真步骤"><a class="markdownIt-Anchor" href="#主要仿真步骤"></a> 主要仿真步骤</h2><ol><li>设计振子结构:由原理分析可得到，半波对称振子天线中心频率为950MHz，其结构尺寸为半径a=1mm,length=157.9mm,lambda=315.8mm,两臂间隙gap=1mm,分别绘制底面半径皆为a，高度为length和gap的圆柱，再经过布尔运算Subtract得到两段长导线，设置为理想导体。</li><li>再绘制高度为length+lambda/4，底面半径为a+lambda/4的圆柱，作为对称振子的辐射边界，并Assign  Boundary为Radiation。</li><li>在两臂间隙中绘制矩形作为集总端口激励，Y方向长度为2×a,Z方向长度为gap，并Assign Excitation为Lumped Port，设置full port impedance为73.3欧姆，定义积分线沿z轴正反向从矩形下方中点指向上方中点，选择不归一化处理，到此对半波对称振子的结构已设计完毕</li></ol><h2 id="仿真结果"><a class="markdownIt-Anchor" href="#仿真结果"></a> 仿真结果</h2><p><img src="/2023/03/27/%E5%BE%AE%E6%B3%A2-%E5%8D%8A%E6%B3%A2%E5%AF%B9%E7%A7%B0%E6%8C%AF%E5%AD%90/%E5%8D%8A%E6%B3%A2%E5%AF%B9%E7%A7%B0%E6%8C%AF%E5%AD%90.png" alt="图2-1-1 半波对称振子建模结构"></p><h1 id="仿真分析s11分布并进行优化仿真"><a class="markdownIt-Anchor" href="#仿真分析s11分布并进行优化仿真"></a> 仿真分析S11分布并进行优化仿真</h1><h2 id="主要仿真步骤-2"><a class="markdownIt-Anchor" href="#主要仿真步骤-2"></a> 主要仿真步骤</h2><ol><li>Analysis新建Setup1为0.95GHz，设置扫频范围为0.45~1.45GHz,样点间隔设置为101个，开启仿真。在Result中绘制S11 Parameter Plot，插入Marker观察中心频点位置并不位于0.95GHz处。</li><li>考虑到与振子的长度有关，设置Optimistic添加参数扫描分析Parametric。设置优化参数为长度length，范围为140~157.9mm，步长为1，添加后点击开始分析。分析完成后，绘制S11 Parameter Plot会得到一簇曲线，插入X Marker观察到length=151mm时，中心频点位于0.95GHz，满足要求</li><li>设置length为151mm，清除优化参数，重新开启仿真分析</li></ol><h2 id="仿真结果-2"><a class="markdownIt-Anchor" href="#仿真结果-2"></a> 仿真结果</h2><p><img src="/2023/03/27/%E5%BE%AE%E6%B3%A2-%E5%8D%8A%E6%B3%A2%E5%AF%B9%E7%A7%B0%E6%8C%AF%E5%AD%90/%E5%88%9D%E5%A7%8B%E7%BB%93%E6%9E%9C.png" alt="图2-2-1 length为157.9mm时的初始回波损耗曲线"><br><img src="/2023/03/27/%E5%BE%AE%E6%B3%A2-%E5%8D%8A%E6%B3%A2%E5%AF%B9%E7%A7%B0%E6%8C%AF%E5%AD%90/%E4%BC%98%E5%8C%96.png" alt="图2-2-2 进行参数优化"><br><img src="/2023/03/27/%E5%BE%AE%E6%B3%A2-%E5%8D%8A%E6%B3%A2%E5%AF%B9%E7%A7%B0%E6%8C%AF%E5%AD%90/%E4%BC%98%E5%8C%96%E7%BB%93%E6%9E%9C.png" alt="图2-2-3 优化结果length=151mm"><br><img src="/2023/03/27/%E5%BE%AE%E6%B3%A2-%E5%8D%8A%E6%B3%A2%E5%AF%B9%E7%A7%B0%E6%8C%AF%E5%AD%90/%E4%BC%98%E5%8C%96%E5%90%8E%E7%9A%84s%E5%8F%82%E6%95%B0%E6%9B%B2%E7%BA%BF.png" alt="图2-2-4 设置length=151mm时的回波损耗分析"></p><h1 id="仿真分析对称振子天线的输入阻抗-回波损耗-方向图等"><a class="markdownIt-Anchor" href="#仿真分析对称振子天线的输入阻抗-回波损耗-方向图等"></a> 仿真分析对称振子天线的输入阻抗、回波损耗、方向图等</h1><h2 id="主要仿真步骤-3"><a class="markdownIt-Anchor" href="#主要仿真步骤-3"></a> 主要仿真步骤</h2><ol><li>根据优化后的结果已经设置好length为151mm，S11输入回波损耗分析如图2-2-4所示，在Result栏可绘制Z Parameter Plot分析输入阻抗图像，选择re(实部)和im(虚部)；</li><li>绘制辐射方向图，在Radiation一栏添加3D视图、E面、H面的远场辐射的求解方式，设置Phi角和Theta角范围如图2-3-1，图2-3-2，图2-3-3所示</li></ol><p><img src="/2023/03/27/%E5%BE%AE%E6%B3%A2-%E5%8D%8A%E6%B3%A2%E5%AF%B9%E7%A7%B0%E6%8C%AF%E5%AD%90/3D%E6%B1%82%E8%A7%A3.png" alt="图2-3-1 3D求解设置"><br><img src="/2023/03/27/%E5%BE%AE%E6%B3%A2-%E5%8D%8A%E6%B3%A2%E5%AF%B9%E7%A7%B0%E6%8C%AF%E5%AD%90/Eplane%E6%B1%82%E8%A7%A3.png" alt="图2-3-2 Eplane求解设置"><br><img src="/2023/03/27/%E5%BE%AE%E6%B3%A2-%E5%8D%8A%E6%B3%A2%E5%AF%B9%E7%A7%B0%E6%8C%AF%E5%AD%90/Hplane%E6%B1%82%E8%A7%A3.png" alt="图2-3-3 Hplane求解设置"></p><ol start="3"><li>在Result一栏右键Create Far Fields Report-3D Polar Plot，依次在Geometry栏选择3D、Eplane、Hplane，绘制辐射方向图。</li></ol><h2 id="仿真结果-3"><a class="markdownIt-Anchor" href="#仿真结果-3"></a> 仿真结果</h2><p><img src="/2023/03/27/%E5%BE%AE%E6%B3%A2-%E5%8D%8A%E6%B3%A2%E5%AF%B9%E7%A7%B0%E6%8C%AF%E5%AD%90/%E8%BE%93%E5%85%A5%E9%98%BB%E6%8A%97.png" alt="图2-3-4 输入阻抗特性"><br><img src="/2023/03/27/%E5%BE%AE%E6%B3%A2-%E5%8D%8A%E6%B3%A2%E5%AF%B9%E7%A7%B0%E6%8C%AF%E5%AD%90/3D.png" alt="图2-3-5 辐射场3D图示"><br><img src="/2023/03/27/%E5%BE%AE%E6%B3%A2-%E5%8D%8A%E6%B3%A2%E5%AF%B9%E7%A7%B0%E6%8C%AF%E5%AD%90/Eplane.png" alt="图2-3-6 Eplane辐射场图示"><br><img src="/2023/03/27/%E5%BE%AE%E6%B3%A2-%E5%8D%8A%E6%B3%A2%E5%AF%B9%E7%A7%B0%E6%8C%AF%E5%AD%90/Hplane.png" alt="图2-3-7 Hplane辐射场图示"></p>]]></content>
    
    
    <categories>
      
      <category>Microwave</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HFSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微波-矩形波导设计仿真与分析</title>
    <link href="/2023/03/25/%E5%BE%AE%E6%B3%A2-%E7%9F%A9%E5%BD%A2%E6%B3%A2%E5%AF%BC%E8%AE%BE%E8%AE%A1%E4%BB%BF%E7%9C%9F%E4%B8%8E%E5%88%86%E6%9E%90/"/>
    <url>/2023/03/25/%E5%BE%AE%E6%B3%A2-%E7%9F%A9%E5%BD%A2%E6%B3%A2%E5%AF%BC%E8%AE%BE%E8%AE%A1%E4%BB%BF%E7%9C%9F%E4%B8%8E%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="微波-矩形波导设计仿真与分析"><a class="markdownIt-Anchor" href="#微波-矩形波导设计仿真与分析"></a> 微波-矩形波导设计仿真与分析</h1><h2 id="使用hfss软件设计建模bj-32矩形波导结构"><a class="markdownIt-Anchor" href="#使用hfss软件设计建模bj-32矩形波导结构"></a> 使用HFSS软件设计建模BJ-32矩形波导结构</h2><h3 id="主要仿真步骤"><a class="markdownIt-Anchor" href="#主要仿真步骤"></a> 主要仿真步骤</h3><p>BJ-32矩形波导结构尺寸为a×b=72.14×34.04mm,长为200mm,在属性窗口设置矩形波导中传输介质为空气，透明度为0.8，设置边界条件和端口激励</p><h3 id="仿真结果"><a class="markdownIt-Anchor" href="#仿真结果"></a> 仿真结果</h3><p>BJ-32矩形波导结构如图2-1所示<br><img src="/2023/03/25/%E5%BE%AE%E6%B3%A2-%E7%9F%A9%E5%BD%A2%E6%B3%A2%E5%AF%BC%E8%AE%BE%E8%AE%A1%E4%BB%BF%E7%9C%9F%E4%B8%8E%E5%88%86%E6%9E%90/%E5%9B%BE2-1-1.png" alt="图2-1-1 BJ-32矩形波导结构"></p><h2 id="仿真分析te10模的场分布管壁电流分布"><a class="markdownIt-Anchor" href="#仿真分析te10模的场分布管壁电流分布"></a> 仿真分析TE10模的场分布，管壁电流分布</h2><h3 id="主要仿真步骤-2"><a class="markdownIt-Anchor" href="#主要仿真步骤-2"></a> 主要仿真步骤</h3><ol><li>设置工作频率为2.8GHz+学号尾号*100MHz，即3.3GHz, HFSS&gt;Analysis Setup&gt;Add Solution Setup，可以进行自适应频率和收敛标准的设置，设置solution Frequency，Setup1=3.3GHz；设置扫频：Setup1→Add Frequency Sweep→Interpolating差值扫频 1~10GHz。</li><li>右键Setup1，选择Analyze进行分析。对Setup1分析完毕后，可观察场分布，选择Field overlays右键editsource，可以查看不同模式的场，此处分析TE10模的场分布，故选择Source为1：1的场，取Magnitude为1，其余为0；选择Plot Fields中的Mag_E（电场瞬时幅度变化）、Vector_E(电场瞬时矢量)和Vector_H(磁场瞬时矢量)可观察TE10模的电场和磁场分布；选Vector_Jsurf可观察管壁表面电流分布</li></ol><h3 id="仿真结果-2"><a class="markdownIt-Anchor" href="#仿真结果-2"></a> 仿真结果</h3><p><img src="/2023/03/25/%E5%BE%AE%E6%B3%A2-%E7%9F%A9%E5%BD%A2%E6%B3%A2%E5%AF%BC%E8%AE%BE%E8%AE%A1%E4%BB%BF%E7%9C%9F%E4%B8%8E%E5%88%86%E6%9E%90/%E5%9B%BE2-2-1.png" alt="图2-2-1 电场瞬时幅度变化(3.3GHz TE10模)"></p><p><img src="/2023/03/25/%E5%BE%AE%E6%B3%A2-%E7%9F%A9%E5%BD%A2%E6%B3%A2%E5%AF%BC%E8%AE%BE%E8%AE%A1%E4%BB%BF%E7%9C%9F%E4%B8%8E%E5%88%86%E6%9E%90/%E5%9B%BE2-2-2.png" alt="图2-2-2 电场瞬时矢量（3.3GHz TE10模)"><br><img src="/2023/03/25/%E5%BE%AE%E6%B3%A2-%E7%9F%A9%E5%BD%A2%E6%B3%A2%E5%AF%BC%E8%AE%BE%E8%AE%A1%E4%BB%BF%E7%9C%9F%E4%B8%8E%E5%88%86%E6%9E%90/%E5%9B%BE2-2-3.png" alt="图2-2-3 磁场瞬时矢量（3.3GHz TE10模)"><br><img src="/2023/03/25/%E5%BE%AE%E6%B3%A2-%E7%9F%A9%E5%BD%A2%E6%B3%A2%E5%AF%BC%E8%AE%BE%E8%AE%A1%E4%BB%BF%E7%9C%9F%E4%B8%8E%E5%88%86%E6%9E%90/%E5%9B%BE2-2-4.png" alt="图2-2-4 管壁表面电流分布（3.3GHz TE10模）"></p><h2 id="仿真并验证矩形波导的传输截止特性"><a class="markdownIt-Anchor" href="#仿真并验证矩形波导的传输截止特性"></a> 仿真并验证矩形波导的传输截止特性</h2><h3 id="主要仿真步骤-3"><a class="markdownIt-Anchor" href="#主要仿真步骤-3"></a> 主要仿真步骤</h3><ol><li>选择Result-Modal Solution Data Report-2D,选择S Parameter,勾选S（2：1，1：1），S(2:2,1:2),S(2:3,1:3)，即选择TE10，TE20，TE01模，可绘制S参数分析曲线，在曲线图单击鼠标右键-Marker-Add X Marker,移动光标可观察传输截止特性</li><li>鼠标右键Analysis-Add Solution Setup,添加Setup2为4.18GHz（TE10和TE20传输，但TE01模截止时频率），添加Setup3为5GHz(此频率下，都可传输)；以电场瞬时幅度变化为观察量仿真在4.18GHz和5GHz下的传输截止特性，右键Mag_E（电场瞬时幅度变化）挑战频率为Setup2和Setup3，具体操作步骤与项目二类似，并可右键选择Mag_E的Animate观察动态传输图像</li></ol><h3 id="仿真结果-3"><a class="markdownIt-Anchor" href="#仿真结果-3"></a> 仿真结果</h3><p><img src="/2023/03/25/%E5%BE%AE%E6%B3%A2-%E7%9F%A9%E5%BD%A2%E6%B3%A2%E5%AF%BC%E8%AE%BE%E8%AE%A1%E4%BB%BF%E7%9C%9F%E4%B8%8E%E5%88%86%E6%9E%90/%E5%9B%BE2-3-1.png" alt="图2-3-1 TE10,TE20，TE01的S参数特性曲线"><br>由图像x轴光标可看出，TE10，TE20截止频率为2.08GHz，4.18GHz，故可选定Setup2为4.18GHz，仿真验证此时TE10，TE20模传输而TE01模截止特性。<br><img src="/2023/03/25/%E5%BE%AE%E6%B3%A2-%E7%9F%A9%E5%BD%A2%E6%B3%A2%E5%AF%BC%E8%AE%BE%E8%AE%A1%E4%BB%BF%E7%9C%9F%E4%B8%8E%E5%88%86%E6%9E%90/%E5%9B%BE2-3-2.png" alt="图2-3-2 TE10,TE20，TE01的S参数特性曲线"><br>由图像x轴光标可看出，TE01截止频率为4.42GHz，故可选定Setup3为5GHz，仿真验证此时TE10，TE20，TE01模均可传输。<br><img src="/2023/03/25/%E5%BE%AE%E6%B3%A2-%E7%9F%A9%E5%BD%A2%E6%B3%A2%E5%AF%BC%E8%AE%BE%E8%AE%A1%E4%BB%BF%E7%9C%9F%E4%B8%8E%E5%88%86%E6%9E%90/%E5%9B%BE2-3-3.png" alt="图2-3-3 电场瞬时幅度变化(3.3GHz TE20模)-截止"><br><img src="/2023/03/25/%E5%BE%AE%E6%B3%A2-%E7%9F%A9%E5%BD%A2%E6%B3%A2%E5%AF%BC%E8%AE%BE%E8%AE%A1%E4%BB%BF%E7%9C%9F%E4%B8%8E%E5%88%86%E6%9E%90/%E5%9B%BE2-3-4.png" alt="图2-3-4 电场瞬时幅度变化(3.3GHz TE01模)-截止"><br><img src="/2023/03/25/%E5%BE%AE%E6%B3%A2-%E7%9F%A9%E5%BD%A2%E6%B3%A2%E5%AF%BC%E8%AE%BE%E8%AE%A1%E4%BB%BF%E7%9C%9F%E4%B8%8E%E5%88%86%E6%9E%90/%E5%9B%BE2-3-5.png" alt="图2-3-5 电场瞬时幅度变化(4.18GHz TE10模)-传输"><br><img src="/2023/03/25/%E5%BE%AE%E6%B3%A2-%E7%9F%A9%E5%BD%A2%E6%B3%A2%E5%AF%BC%E8%AE%BE%E8%AE%A1%E4%BB%BF%E7%9C%9F%E4%B8%8E%E5%88%86%E6%9E%90/%E5%9B%BE2-3-6.png" alt="图2-3-6 电场瞬时幅度变化(4.18GHz TE20模)-传输"><br><img src="/2023/03/25/%E5%BE%AE%E6%B3%A2-%E7%9F%A9%E5%BD%A2%E6%B3%A2%E5%AF%BC%E8%AE%BE%E8%AE%A1%E4%BB%BF%E7%9C%9F%E4%B8%8E%E5%88%86%E6%9E%90/%E5%9B%BE2-3-7.png" alt="图2-3-7 电场瞬时幅度变化(4.18GHz TE01模)-截止"><br><img src="/2023/03/25/%E5%BE%AE%E6%B3%A2-%E7%9F%A9%E5%BD%A2%E6%B3%A2%E5%AF%BC%E8%AE%BE%E8%AE%A1%E4%BB%BF%E7%9C%9F%E4%B8%8E%E5%88%86%E6%9E%90/%E5%9B%BE2-3-8.png" alt="图2-3-8 电场瞬时幅度变化(5GHz TE10模)-传输"><br><img src="/2023/03/25/%E5%BE%AE%E6%B3%A2-%E7%9F%A9%E5%BD%A2%E6%B3%A2%E5%AF%BC%E8%AE%BE%E8%AE%A1%E4%BB%BF%E7%9C%9F%E4%B8%8E%E5%88%86%E6%9E%90/%E5%9B%BE2-3-9.png" alt="图2-3-9 电场瞬时幅度变化(5GHz TE20模)-传输"><br><img src="/2023/03/25/%E5%BE%AE%E6%B3%A2-%E7%9F%A9%E5%BD%A2%E6%B3%A2%E5%AF%BC%E8%AE%BE%E8%AE%A1%E4%BB%BF%E7%9C%9F%E4%B8%8E%E5%88%86%E6%9E%90/%E5%9B%BE2-3-10.png" alt="图2-3-10 电场瞬时幅度变化(5GHz TE01模)-传输"></p><h2 id="仿真bj-32矩形波导te10-te20-te01模式的场分布"><a class="markdownIt-Anchor" href="#仿真bj-32矩形波导te10-te20-te01模式的场分布"></a> 仿真BJ-32矩形波导TE10、TE20、TE01模式的场分布</h2><h3 id="主要仿真步骤-4"><a class="markdownIt-Anchor" href="#主要仿真步骤-4"></a> 主要仿真步骤</h3><p>分析Setup3=5GHz三个频率下的TE10、TE20、TE01模的场分布，在此频率下均可传播，具体操作步骤与项目二类似</p><h3 id="仿真结果-4"><a class="markdownIt-Anchor" href="#仿真结果-4"></a> 仿真结果</h3><p><img src="/2023/03/25/%E5%BE%AE%E6%B3%A2-%E7%9F%A9%E5%BD%A2%E6%B3%A2%E5%AF%BC%E8%AE%BE%E8%AE%A1%E4%BB%BF%E7%9C%9F%E4%B8%8E%E5%88%86%E6%9E%90/%E5%9B%BE2-4-1.png" alt="图2-4-1电场瞬时幅度变化（5GHz TE10模）"><br><img src="/2023/03/25/%E5%BE%AE%E6%B3%A2-%E7%9F%A9%E5%BD%A2%E6%B3%A2%E5%AF%BC%E8%AE%BE%E8%AE%A1%E4%BB%BF%E7%9C%9F%E4%B8%8E%E5%88%86%E6%9E%90/%E5%9B%BE2-4-2.png" alt="图2-4-2 电场瞬时矢量（5GHz TE10模）"><br><img src="/2023/03/25/%E5%BE%AE%E6%B3%A2-%E7%9F%A9%E5%BD%A2%E6%B3%A2%E5%AF%BC%E8%AE%BE%E8%AE%A1%E4%BB%BF%E7%9C%9F%E4%B8%8E%E5%88%86%E6%9E%90/%E5%9B%BE2-4-3.png" alt="图2-4-3 磁场瞬时矢量（5GHz TE10模）"><br><img src="/2023/03/25/%E5%BE%AE%E6%B3%A2-%E7%9F%A9%E5%BD%A2%E6%B3%A2%E5%AF%BC%E8%AE%BE%E8%AE%A1%E4%BB%BF%E7%9C%9F%E4%B8%8E%E5%88%86%E6%9E%90/%E5%9B%BE2-4-4.png" alt="图2-4-4 管壁表面电流分布（5GHz TE10模）"><br><img src="/2023/03/25/%E5%BE%AE%E6%B3%A2-%E7%9F%A9%E5%BD%A2%E6%B3%A2%E5%AF%BC%E8%AE%BE%E8%AE%A1%E4%BB%BF%E7%9C%9F%E4%B8%8E%E5%88%86%E6%9E%90/%E5%9B%BE2-4-5.png" alt="图2-4-5电场瞬时幅度变化（5GHz TE20模）"><br><img src="/2023/03/25/%E5%BE%AE%E6%B3%A2-%E7%9F%A9%E5%BD%A2%E6%B3%A2%E5%AF%BC%E8%AE%BE%E8%AE%A1%E4%BB%BF%E7%9C%9F%E4%B8%8E%E5%88%86%E6%9E%90/%E5%9B%BE2-4-6.png" alt="图2-4-6 电场瞬时矢量（5GHz TE20模）"><br><img src="/2023/03/25/%E5%BE%AE%E6%B3%A2-%E7%9F%A9%E5%BD%A2%E6%B3%A2%E5%AF%BC%E8%AE%BE%E8%AE%A1%E4%BB%BF%E7%9C%9F%E4%B8%8E%E5%88%86%E6%9E%90/%E5%9B%BE2-4-7.png" alt="图2-4-7 磁场瞬时矢量（5GHz TE20模）"><br><img src="/2023/03/25/%E5%BE%AE%E6%B3%A2-%E7%9F%A9%E5%BD%A2%E6%B3%A2%E5%AF%BC%E8%AE%BE%E8%AE%A1%E4%BB%BF%E7%9C%9F%E4%B8%8E%E5%88%86%E6%9E%90/%E5%9B%BE2-4-8.png" alt="图2-4-8 管壁表面电流分布（5GHz TE20模）"><br><img src="/2023/03/25/%E5%BE%AE%E6%B3%A2-%E7%9F%A9%E5%BD%A2%E6%B3%A2%E5%AF%BC%E8%AE%BE%E8%AE%A1%E4%BB%BF%E7%9C%9F%E4%B8%8E%E5%88%86%E6%9E%90/%E5%9B%BE2-4-9.png" alt="图2-4-9电场瞬时幅度变化（5GHz TE01模）"><br><img src="/2023/03/25/%E5%BE%AE%E6%B3%A2-%E7%9F%A9%E5%BD%A2%E6%B3%A2%E5%AF%BC%E8%AE%BE%E8%AE%A1%E4%BB%BF%E7%9C%9F%E4%B8%8E%E5%88%86%E6%9E%90/%E5%9B%BE2-4-10.png" alt="图2-4-10 电场瞬时矢量（5GHz TE01模）"><br><img src="/2023/03/25/%E5%BE%AE%E6%B3%A2-%E7%9F%A9%E5%BD%A2%E6%B3%A2%E5%AF%BC%E8%AE%BE%E8%AE%A1%E4%BB%BF%E7%9C%9F%E4%B8%8E%E5%88%86%E6%9E%90/%E5%9B%BE2-4-11.png" alt="图2-4-11 磁场瞬时矢量（5GHz TE01模）"><br><img src="/2023/03/25/%E5%BE%AE%E6%B3%A2-%E7%9F%A9%E5%BD%A2%E6%B3%A2%E5%AF%BC%E8%AE%BE%E8%AE%A1%E4%BB%BF%E7%9C%9F%E4%B8%8E%E5%88%86%E6%9E%90/%E5%9B%BE2-4-12.png" alt="图2-4-12 管壁表面电流分布（5GHz TE01模）"></p>]]></content>
    
    
    <categories>
      
      <category>Microwave</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HFSS</tag>
      
      <tag>微波</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
